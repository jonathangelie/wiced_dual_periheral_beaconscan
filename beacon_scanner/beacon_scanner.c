/** @file
 *
 * This file has been automatically generated by the WICED Smart Designer. 
 * Device configuration and functions required for the BLE device.
 *
 */

#include "bleprofile.h"
#include "blecen.h"
#include "bleapp.h"
#include "gpiodriver.h"
#include "string.h"
#include "stdio.h"
#include "platform.h"

#include "beacon_scanner_db.h"
#include "beacon_parser.h"

/******************************************************
 *                     Constants
 ******************************************************/

#define BEACON_SCANNER_FINE_TIMER           0
#define BEACON_SCANNER_DEVICE_NAME          "beacon_scanner"
#define BEACON_SCANNER_DEVICE_APPEARENCE    0
#define BEACON_SCANNER_MAIN_SERVICE_UUID    UUID_SERVICE_DEVICE_INFORMATION
#define BEACON_SCANNER_MAIN_CHAR_UUID       UUID_CHARACTERISTIC_MANUFACTURER_NAME_STRING
#define BEACON_SCANNER_MAIN_CHAR_HANDLE     HDLC_DEVICE_INFORMATION_MANUFACTURER_NAME_STRING_VALUE

/******************************************************
 *                     Structures
 ******************************************************/

#pragma pack(1)
//host information for NVRAM
typedef PACKED struct
{
    //part of HOSTINFO generated by wizard
    __HOSTINFO generated;
    // ToDo: add your variables here which need to be saved in the NVRAM
}  HOSTINFO;
#pragma pack()

/******************************************************
 *               Function Prototypes
 ******************************************************/

static void beacon_scanner_create(void);
static void beacon_scanner_connection_up( void );
static void beacon_scanner_connection_down( void );
static void beacon_scanner_advertisement_stopped( void );
static void beacon_scanner_smp_bond_result( LESMP_PARING_RESULT result );
static void beacon_scanner_encryption_changed( HCI_EVT_HDR *evt );
static int  beacon_scanner_write_handler( LEGATTDB_ENTRY_HDR *p );
static void beacon_scanner_interrupt_handler( UINT8 value );

/******************************************************
 *               Variables Definitions
 ******************************************************/

const BLE_PROFILE_CFG beacon_scanner_cfg =
{
    /*.fine_timer_interval            =*/ BEACON_SCANNER_FINE_TIMER, // ms
    /*.default_adv                    =*/ 4,    // HIGH_UNDIRECTED_DISCOVERABLE
    /*.button_adv_toggle              =*/ 0,    // pairing button make adv toggle (if 1) or always on (if 0)
    /*.high_undirect_adv_interval     =*/ 32,   // slots
    /*.low_undirect_adv_interval      =*/ 1024, // slots
    /*.high_undirect_adv_duration     =*/ 30,   // seconds
    /*.low_undirect_adv_duration      =*/ 300,  // seconds
    /*.high_direct_adv_interval       =*/ 0,    // seconds
    /*.low_direct_adv_interval        =*/ 0,    // seconds
    /*.high_direct_adv_duration       =*/ 0,    // seconds
    /*.low_direct_adv_duration        =*/ 0,    // seconds
    /*.local_name                     =*/ BEACON_SCANNER_DEVICE_NAME, // [LOCAL_NAME_LEN_MAX];
    /*.cod                            =*/ BIT16_TO_8(BEACON_SCANNER_DEVICE_APPEARENCE),0x00, // [COD_LEN];
    /*.ver                            =*/ "1.00",         // [VERSION_LEN];
    /*.encr_required                  =*/ 0,    //(SECURITY_ENABLED | SECURITY_REQUEST),    // data encrypted and device sends security request on every connection
    /*.disc_required                  =*/ 0,    // if 1, disconnection after confirmation
    /*.test_enable                    =*/ 1,    // TEST MODE is enabled when 1
    /*.tx_power_level                 =*/ 0x04, // dbm
    /*.con_idle_timeout               =*/ 30,   // second  0-> no timeout
    /*.powersave_timeout              =*/ 0,    // second  0-> no timeout
    /*.hdl                            =*/ {BEACON_SCANNER_MAIN_CHAR_HANDLE, 0x00, 0x00, 0x00, 0x00}, // [HANDLE_NUM_MAX];
    /*.serv                           =*/ {BEACON_SCANNER_MAIN_SERVICE_UUID, 0x00, 0x00, 0x00, 0x00},
    /*.cha                            =*/ {BEACON_SCANNER_MAIN_CHAR_UUID, 0x00, 0x00, 0x00, 0x00},
    /*.findme_locator_enable          =*/ 0,    // if 1 Find me locator is enable
    /*.findme_alert_level             =*/ 0,    // alert level of find me
    /*.client_grouptype_enable        =*/ 0,    // if 1 grouptype read can be used
    /*.linkloss_button_enable         =*/ 0,    // if 1 linkloss button is enable
    /*.pathloss_check_interval        =*/ 0,    // second
    /*.alert_interval                 =*/ 0,    // interval of alert
    /*.high_alert_num                 =*/ 0,    // number of alert for each interval
    /*.mild_alert_num                 =*/ 0,    // number of alert for each interval
    /*.status_led_enable              =*/ 1,    // if 1 status LED is enable
    /*.status_led_interval            =*/ 0,    // second
    /*.status_led_con_blink           =*/ 0,    // blink num of connection
    /*.status_led_dir_adv_blink       =*/ 0,    // blink num of dir adv
    /*.status_led_un_adv_blink        =*/ 0,    // blink num of undir adv
    /*.led_on_ms                      =*/ 0,    // led blink on duration in ms
    /*.led_off_ms                     =*/ 0,    // led blink off duration in ms
    /*.buz_on_ms                      =*/ 100,  // buzzer on duration in ms
    /*.button_power_timeout           =*/ 0,    // seconds
    /*.button_client_timeout          =*/ 0,    // seconds
    /*.button_discover_timeout        =*/ 0,    // seconds
    /*.button_filter_timeout          =*/ 0,    // seconds
#ifdef BLE_UART_LOOPBACK_TRACE
    /*.button_uart_timeout            =*/ 15,   // seconds
#endif
};

// Following structure defines UART configuration
const BLE_PROFILE_PUART_CFG beacon_scanner_puart_cfg =
{
    /*.baudrate   =*/ 115200,
#ifdef GATT_DB_ENABLE_UART
    /*.txpin      =*/ GPIO_PIN_UART_TX,
    /*.rxpin      =*/ GPIO_PIN_UART_RX,
#else
    /*.txpin      =*/ PUARTDISABLE | GPIO_PIN_UART_TX,
    /*.rxpin      =*/ PUARTDISABLE | GPIO_PIN_UART_RX,
#endif
};

// NVRAM save area
HOSTINFO beacon_scanner_hostinfo;
//pointer to the generated part of hostinfo assuming it is the beginning of the hostinfo
__HOSTINFO *p_hostinfo_generated = &beacon_scanner_hostinfo.generated;

UINT16 	beacon_scanner_connection_handle      = 0;                  // HCI handle of connection, not zero when connected
BD_ADDR beacon_scanner_remote_addr            = {0, 0, 0, 0, 0, 0}; // Address of currently connected client

/* variable defined in blecen.c required during scanning procedure */
extern BLE_CEN_CFG		blecen_cen_cfg;
extern BLEAPP_TIMER_CB	blecen_usertimerCb;
/******************************************************
 *               Function Definitions
 ******************************************************/

// Application initialization
APPLICATION_INIT()
{
	bleapp_set_cfg((UINT8 *) gatt_database,
				   gatt_database_len,
				   (void *) &beacon_scanner_cfg,
				   (void *) &beacon_scanner_puart_cfg,
				   (void *) &beacon_scanner_gpio_cfg,
				   beacon_scanner_create);
}

static void beacon_scanner_timer_callback(UINT32 arg)
{
	ble_trace1("beacon_scanner_timer_callback %d\n", arg);

	switch (arg) {
	case BLEAPP_APP_TIMER_SCAN:
		/* scan timeout, lets start advertising */
		bleprofile_Discoverable(HIGH_UNDIRECTED_DISCOVERABLE, NULL);
		break;

	case BLEAPP_APP_TIMER_CONN:
		/* nothing to do as we do not initiating any connection request */
		break;
	}
}

static void beacon_scanner_advertisement_report(HCIULP_ADV_PACKET_REPORT_WDATA *evt)
{
	/* Reset watch dog timer every time we see an advertisement,
	 * in case we received too much packet */
	wdog_restart();

	if (evt->dataLen > HCIULP_MAX_DATA_LENGTH) {
		return;
	} else {
		enum beacon_type btype;
		beacon_parser(evt, &btype);
		if (btype != TYPE_UNKNOWN)
			ble_trace3("beacon (%d) detected\n", btype);
	}
}
// Create device
void beacon_scanner_create(void)
{
	extern UINT8 bleprofile_adv_num;
	extern UINT8 bleprofile_scanrsp_num;

	ble_trace0("create()");
	ble_trace0(bleprofile_p_cfg->ver);

	bleprofile_adv_num = 0x0;
	bleprofile_scanrsp_num = 0x0;

	legattdb_dumpDb();

	/* scan initialization */
	/* filter duplicate advertisement packet */
	blecen_cen_cfg.filter_duplicates = HCIULP_SCAN_DUPLICATE_FILTER_OFF;
	/* function called on scan timeout event high_scan_duration = 30s*/
	blecen_usertimerCb = beacon_scanner_timer_callback;

	bleprofile_Init(bleprofile_p_cfg);
	bleprofile_GPIOInit(bleprofile_gpio_p_cfg);

	/* Initialized ROM code which will monitor the battery */
	blebat_Init();

	/* Read NVRAM */
	bleprofile_ReadNVRAM(VS_BLE_HOST_LIST, sizeof(beacon_scanner_hostinfo),
			(UINT8 *) &beacon_scanner_hostinfo);

	/* register to scan report */
	blecm_RegleAdvReportCb(
			(BLECM_FUNC_WITH_PARAM) beacon_scanner_advertisement_report);

	/* register connection up and connection down handler */
	bleprofile_regAppEvtHandler(BLECM_APP_EVT_LINK_UP,
			beacon_scanner_connection_up);
	bleprofile_regAppEvtHandler(BLECM_APP_EVT_LINK_DOWN,
			beacon_scanner_connection_down);
	bleprofile_regAppEvtHandler(BLECM_APP_EVT_ADV_TIMEOUT,
			beacon_scanner_advertisement_stopped);

	/* handler for Encryption changed */
	blecm_regEncryptionChangedHandler(beacon_scanner_encryption_changed);

	/* handler for Bond result */
	lesmp_regSMPResultCb(
			(LESMP_SINGLE_PARAM_CB) beacon_scanner_smp_bond_result);

	/* register to process client writes */
	legattdb_regWriteHandleCb((LEGATTDB_WRITE_CB) beacon_scanner_write_handler);

	/* register interrupt handler */
	bleprofile_regIntCb(
			(BLEPROFILE_SINGLE_PARAM_CB) beacon_scanner_interrupt_handler);

	/* registers timer */
	beacon_scanner_reg_timer();

	/* advertise first vendor specific service */
	if (sizeof(beacon_scanner_uuid_main_service) > 1) {
		/* total length should be less than 31 bytes */
		BLE_ADV_FIELD adv[3];
		BLE_ADV_FIELD scr[1];

		/* flags */
		adv[0].len = 1 + 1;
		adv[0].val = ADV_FLAGS;
		adv[0].data[0] = LE_LIMITED_DISCOVERABLE | BR_EDR_NOT_SUPPORTED;

		adv[1].len = sizeof(beacon_scanner_uuid_main_service) + 1;
		adv[1].val =
				sizeof(beacon_scanner_uuid_main_service) == 16 ?
						ADV_SERVICE_UUID128_COMP : ADV_SERVICE_UUID16_COMP;
		memcpy(adv[1].data, &beacon_scanner_uuid_main_service[0],
				sizeof(beacon_scanner_uuid_main_service));

		/* Tx power level */
		adv[2].len = TX_POWER_LEN + 1;
		adv[2].val = ADV_TX_POWER_LEVEL;
		adv[2].data[0] = bleprofile_p_cfg->tx_power_level;

		/* name */
		scr[0].len = strlen(bleprofile_p_cfg->local_name) + 1;
		scr[0].val = ADV_LOCAL_NAME_COMP;
		memcpy(scr[0].data, bleprofile_p_cfg->local_name, scr[0].len - 1);

		bleprofile_GenerateADVData(adv, 3);
		bleprofile_GenerateScanRspData(scr, 1);
	}

	blecm_setTxPowerInADV(0);

	/* start device advertisements */
	bleprofile_Discoverable(HIGH_UNDIRECTED_DISCOVERABLE, NULL);
}

/* on_Connection event */
void beacon_scanner_connection_up(void)
{
	beacon_scanner_connection_handle = (UINT16)emconinfo_getConnHandle();
	UINT8 *bda = (UINT8 *)emconninfo_getPeerPubAddr();

	// Save address of the connected device and print it out.
	memcpy(beacon_scanner_remote_addr, bda, sizeof(beacon_scanner_remote_addr));

	ble_trace3("connection_up handle:%d | %02x:%02x:%02x:%02x:%02x:%02x",
			beacon_scanner_connection_handle,
			   beacon_scanner_remote_addr[5], beacon_scanner_remote_addr[4],
			   beacon_scanner_remote_addr[3], beacon_scanner_remote_addr[2],
			   beacon_scanner_remote_addr[1], beacon_scanner_remote_addr[0]);


	/* Prepare generated code for connection */
	__on_connection_up();

	/* stop advertising as only one connection is supported */
	bleprofile_Discoverable(NO_DISCOVERABLE, NULL);

	/* if required, initializing encryption */
	if (bleprofile_p_cfg->encr_required & SECURITY_REQUEST) {
		if (emconninfo_deviceBonded()) {
			ble_trace0("device bonded");
		} else {
			ble_trace0("device not bonded");
			lesmp_sendSecurityRequest();
		}
	}
}

// Connection down callback
void beacon_scanner_connection_down(void)
{
	ble_trace1("connection_down:handle:%d", beacon_scanner_connection_handle);

	beacon_scanner_connection_handle = 0;

	// If disconnection was caused by the peer, start low advertisements
	bleprofile_Discoverable(LOW_UNDIRECTED_DISCOVERABLE, NULL);
}

/* on advertising timeout */
void beacon_scanner_advertisement_stopped(void)
{
	/*
	 * if none connection has been established within advertising timeout,
	 * initiate a scan for detection beacons nearby
	 */
	ble_trace0("ADV stop!!!!");
	/* starting BLE scan high frequency */
	blecen_Scan(HIGH_SCAN);
}

/* SMP bonding complete event */
void beacon_scanner_smp_bond_result(LESMP_PARING_RESULT  result)
{
	ble_trace1("smp_bond_result %02x", result);

	if (result == LESMP_PAIRING_RESULT_BONDED) {
		/* saving bd_addr in nvram */
		UINT8 *bda;
		UINT8 writtenbyte;

		bda = (UINT8 *)emconninfo_getPeerPubAddr();

		/* initialize persistent values in the hostinfo to add bonded peer */
		beacon_scanner_add_bond(bda);

		/* writting hostinfo into NVRAM */
		writtenbyte = bleprofile_WriteNVRAM(VS_BLE_HOST_LIST,
											sizeof(beacon_scanner_hostinfo),
											(UINT8 *)&beacon_scanner_hostinfo);
		ble_trace1("NVRAM write:%04x", writtenbyte);
	}
}

/* Notification from the stack that encryption has been set */
void beacon_scanner_encryption_changed(HCI_EVT_HDR *evt)
{
	UINT8 *bda = emconninfo_getPeerPubAddr();

	ble_trace2("encryption changed %02x:%02x:%02x:%02x:%02x:%02x",
				bda[5], bda[4], bda[3],
				bda[2], bda[1], bda[0]);

	/* polling every 100-500 msec, with link supervision timeout 5 seconds */
	bleprofile_SendConnParamUpdateReq(80, 400, 0, 500);
}

/* on write request or command */
int beacon_scanner_write_handler(LEGATTDB_ENTRY_HDR *p)
{
	UINT8  writtenbyte;
	UINT16 handle   = legattdb_getHandle(p);
	int    len      = legattdb_getAttrValueLen(p);
	UINT8  *attrPtr = legattdb_getAttrValue(p);
	BOOL changed;

	ble_trace1("write_handler: handle %04x", handle);

	changed = __write_handler(handle, len, attrPtr);

	/* Save update to NVRAM if it has been changed */
	if (changed) {
		writtenbyte = bleprofile_WriteNVRAM(VS_BLE_HOST_LIST,
											sizeof(beacon_scanner_hostinfo),
											(UINT8 *)&beacon_scanner_hostinfo);
		ble_trace1("NVRAM write:%04x", writtenbyte);
	}
	return 0;
}

/* interrupt handler */
void beacon_scanner_interrupt_handler(UINT8 value)
{
}

/* on indication confirmation */
void beacon_scanner_indication_cfm(void)
{
}


// It will be called every 1 sec
void beacon_scanner_timer_1s()
{
    //Todo: do you actions here every 1 second
}

